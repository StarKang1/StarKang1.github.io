<!DOCTYPE html><html lang="ch" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++核心编程(一) | WayJay's Blog</title><meta name="author" content="WayJay"><meta name="copyright" content="WayJay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++核心编程本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。 1内存分区模型C++程序在执行时，将内存大方向划分为4个区域 a.代码区：存放函数体的二进制代码，由操作系统进行管理的b.全局区：存放全局变量和静态变量以及常量栈区：由编译器自动分配释放，存放函数的参数值，局部变量等c.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区意义：不同区域">
<meta property="og:type" content="article">
<meta property="og:title" content="C++核心编程(一)">
<meta property="og:url" content="http://example.com/2022/03/31/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="WayJay&#39;s Blog">
<meta property="og:description" content="C++核心编程本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。 1内存分区模型C++程序在执行时，将内存大方向划分为4个区域 a.代码区：存放函数体的二进制代码，由操作系统进行管理的b.全局区：存放全局变量和静态变量以及常量栈区：由编译器自动分配释放，存放函数的参数值，局部变量等c.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区意义：不同区域">
<meta property="og:locale">
<meta property="og:image" content="https://picsum.photos/id/802/300/300">
<meta property="article:published_time" content="2022-03-30T16:06:21.000Z">
<meta property="article:modified_time" content="2024-01-02T07:42:26.025Z">
<meta property="article:author" content="WayJay">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picsum.photos/id/802/300/300"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/03/31/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++核心编程(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-02 15:42:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.wxcha.com/file/201808/31/9b99c1b0d7.jpg?down" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-navicon-wzgl"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-ziyuanxhdpi"></i><span> 日志</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-24gl-folderOpen"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxiankafeiyule"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-vynil"></i><span> 歌单</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont icon-dianying1"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-yuedu1"></i><span> 阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-tukuxiangce"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw iconfont icon-guanyu1"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picsum.photos/id/802/300/300')"><nav id="nav"><span id="blog-info"><a href="/" title="WayJay's Blog"><span class="site-name">WayJay's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-navicon-wzgl"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-ziyuanxhdpi"></i><span> 日志</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-24gl-folderOpen"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxiankafeiyule"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-vynil"></i><span> 歌单</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont icon-dianying1"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-yuedu1"></i><span> 阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-tukuxiangce"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw iconfont icon-guanyu1"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++核心编程(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-03-30T16:06:21.000Z" title="Created 2022-03-31 00:06:21">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-02T07:42:26.025Z" title="Updated 2024-01-02 15:42:26">2024-01-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++核心编程(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1内存分区模型"><a href="#1内存分区模型" class="headerlink" title="1内存分区模型"></a>1内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为4个区域</p>
<p>a.代码区：存放函数体的二进制代码，由操作系统进行管理的<br>b.全局区：存放全局变量和静态变量以及常量<br>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等<br>c.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>
<p><strong>内存四区意义：</strong><br>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>
<h3 id="1-1程序运行前"><a href="#1-1程序运行前" class="headerlink" title="1.1程序运行前"></a>1.1程序运行前</h3><p>在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域<br><em>代码区：</em><br>存放CPU执行的机器指令<br>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可<br>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令<br><em>全局存储区：</em><br>全局变量、静态变量以及<br>全局区还包含了常量区，字符串常量是和其他常量也存放在此<br>该区域的数据在程序结束后由操作系统释放。</p>
<h3 id="1-2程序运行后"><a href="#1-2程序运行后" class="headerlink" title="1.2程序运行后"></a>1.2程序运行后</h3><p><em>栈区：</em></p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等</p>
<p>注意事项：局部变量的地址在函数执行结束后会自动释放掉。不要放回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int *func()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 10;</span><br><span class="line"></span><br><span class="line">  return &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/GV$L%7DQIH0_%7DCNS1U3D2VU44.png"></p>
<p><em>堆区</em></p>
<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统收回</p>
<p>在C++中主要利用new在堆区开辟内存</p>
<p>利用new关键字，可以将数据开辟到堆区</p>
<p>指针 本质上也是局部变量，放在栈上，指针保存的数据是放在堆区的</p>
<p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int c ;</span><br><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">	int *a = new int(10);</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int *b = func();</span><br><span class="line">	int a =10;</span><br><span class="line">	int *p = &amp;a;</span><br><span class="line">	int *x = &amp;c;</span><br><span class="line">	*x = 10;</span><br><span class="line">	cout &lt;&lt; *b&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *b&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *b&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *b&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648645563992.png"></p>
<p>讲到这里，我去搜了一下什么是全局变量、局部变量、静态局部变量以及静态全局变量。</p>
<p>首先，得知道什么是全局、静态、局部</p>
<p>全局：具有文件作用域的变量</p>
<p>静态：具有静态存储器或内部链接性质</p>
<p>局部：具有函数或块作用域的变量</p>
<p>那么</p>
<p>局部变量：函数或块作用域的变量</p>
<p>静态局部变量：函数或块作用域，静态存储期</p>
<p>全局变量：具有文件作用域的变量</p>
<p>静态全局变量：内部链接属性的，具有文件作用域的变量</p>
<p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 10;</span><br><span class="line">static int b = 10;</span><br><span class="line">const int e = 20;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int c = 10;</span><br><span class="line">	static int temp = 10;</span><br><span class="line">	const int d = 10;</span><br><span class="line">	cout &lt;&lt;&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&amp;b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&amp;c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&amp;temp &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;&quot;hello world&quot; &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt;&amp;d &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&amp;e &lt;&lt; endl;</span><br><span class="line">//结果说明全局变量、const修饰的全局变量、静态全局变量、静态局部变量以及字符串常量都是在全局存储区</span><br><span class="line">//而局部变量、const修饰的局部变量在栈区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具有文件作用域的变量具有静态存储期，并且具有链接属性</p>
<p>不希望其他文件访问的文件作用域变量最好用static修饰</p>
<p>尽可能不使用全局变量，因为它可能带来变量被以为修改</p>
<p>栈内存响应比动态内存快，但是栈内存有限</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>C++中利用new操作符在堆区开辟数据</p>
<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p>
<p><em>语法：</em>new数据类型</p>
<p>利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">	int* p = new int(10);//new开辟堆区间</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int *a = func(); //</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	delete a; //手动释放</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648649204694.png"></p>
<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用：</strong>给变量起别名</p>
<p><strong>语法：</strong>数据类型 &amp;别名 &#x3D; 原名</p>
<p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//引用的本质是给某个变量取别名</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int &amp;b = a; //给a取别名为b</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	//这里a和b的地址是一样的</span><br><span class="line">	//说明a b指向的地址是一样的，所以保存的数据也是一样的,我是这么理解的qAq</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	b = 100;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648650774020.png"></p>
<h3 id="2-2引用注意事项"><a href="#2-2引用注意事项" class="headerlink" title="2.2引用注意事项"></a>2.2引用注意事项</h3><p>引用必须初始化</p>
<p>引用在初始化后，不可以改变</p>
<p><strong>代码实验：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int c =10;</span><br><span class="line">	// int &amp;b; // 错误，引用必须初始化</span><br><span class="line">	int &amp;b = a; //一旦初始化，不可重复初始化</span><br><span class="line">	// int &amp;b = c;报错： redeclaration of ‘int&amp; b’ 重复声明</span><br><span class="line">	c = b; //赋值操作，并不是初始化</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648651363188.png"></p>
<p>说明赋值并不是引用</p>
<h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p><strong>代码实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//演示 值传递 地址传递 引用传递的不同</span><br><span class="line">//值传递数值交换 地址随机分配内存， 形参不修饰实参 地址发生改变</span><br><span class="line">void swap1(int a ,int b)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;值传递后的值&quot;&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  *a= &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; &quot;  *a= &quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//地址传递 地址和数值都交换了 </span><br><span class="line">void swap2(int * a,int * b)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = *a;</span><br><span class="line">	*a = *b ;</span><br><span class="line">	*b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;地址传递后的值&quot;&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; *a &lt;&lt; &quot;  *a= &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b = &quot; &lt;&lt; *b &lt;&lt; &quot;  *b= &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//引用传递,地址没有交换，数值交换了</span><br><span class="line">void swap3(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;引用传递后的值&quot;&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  *a= &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; &quot;  *b= &quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 30;</span><br><span class="line">	cout &lt;&lt; &quot;未交换前的实参的值&quot;&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  *a= &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; &quot;  *b= &quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">	swap1(a,b);</span><br><span class="line">	swap2(&amp;a,&amp;b);</span><br><span class="line">	swap3(a,b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648709199204.png"></p>
<p>值传递属于是形参不修饰实参，没有修饰符，可以发现值传递的值交换了，地址是随机分配的</p>
<p>地址传递和引用传递属于是形参修饰实参，地址传递的值交换了，地址没有交换，<br>引用传递的值发生了交换，地址没有发生交换，也就是相当于给变量取了别的名字，这个名字所赋的值也会跟随过来，简化指针修改实参。</p>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意： 不要返回局部变量</p>
<p>用法： 函数调用作为左值</p>
<p><strong>代码实验：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int &amp;num()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int &amp;ref = num();</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648713008951.png"></p>
<p><strong>结论：</strong>局部变量不能作为返回值，局部变量的数据保存在栈区，在函数或是块作用域执行结束后内存释放，因此不能作为返回值。</p>
<p><strong>代码实验：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int &amp;num()</span><br><span class="line">&#123;</span><br><span class="line">	static int a = 10;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int &amp;ref = num();</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648713277009.png"></p>
<p><strong>结论：</strong> 静态局部变量的数据保存在全局区，程序结束后内存释放，所以可以作为返回值。</p>
<h3 id="2-5引用的本质"><a href="#2-5引用的本质" class="headerlink" title="2.5引用的本质"></a>2.5引用的本质</h3><p><strong>本质：</strong> 引用的本质在C++内部实现是一个指针常量</p>
<p>即int &amp;a  本质是 int * const a; </p>
<p>指向的地址不可以改变，地址内部的数据是可以修改和查看的</p>
<p><strong>代码实验：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int &amp;ref)</span><br><span class="line">&#123;</span><br><span class="line">	ref = 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int &amp;ref = a;</span><br><span class="line">	ref = 20;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	func(a);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1648715456921.png"></p>
<p><strong>结论：</strong> 从上面的代码可以看出，引用本质是改名，修改变量的名字，对其进行赋值。</p>
<h3 id="2-3常量引用"><a href="#2-3常量引用" class="headerlink" title="2.3常量引用"></a>2.3常量引用</h3><p>作用：常量引用用于修饰形参,防止误操作</p>
<p>在函数参数列表里，可以加上const修饰形参，防止形参改变实参。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void showValue(const int &amp;val) //当你不希望形参改变实参的时候可以用这个，相当于即修饰指针又修饰常量</span><br><span class="line">&#123;</span><br><span class="line">	val = 1000;//当你尝试修改变量的值的时候就会报错</span><br><span class="line">	cout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	showValue(a); </span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3.函数提高"></a>3.函数提高</h2><h3 id="3-1函数默认参数"><a href="#3-1函数默认参数" class="headerlink" title="3.1函数默认参数"></a>3.1函数默认参数</h3><p>在C++中，函数的形参列表中的形象是可以有默认值的</p>
<p>语法：返回值类型 函数名 （参数 &#x3D; 默认值）{ }</p>
<p><strong>注意事项</strong> 如果函数某个位置已经有参数了，那么从这个位置往后都必须有参数</p>
<p><strong>代码实验：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a, int b = 10 ,int c = 20)</span><br><span class="line">&#123;</span><br><span class="line">	return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	cout &lt;&lt; func(10) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2函数占位参数"><a href="#3-2函数占位参数" class="headerlink" title="3.2函数占位参数"></a>3.2函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置。</p>
<p>语法： 返回值类型 函数名 （数据类型） {}</p>
<p>在现阶段函数的占位参数意义不大，但是后面的课程中会用到该技术。</p>
<p><strong>代码实验：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int a ,int)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;This is a function&quot; &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	func(10,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3函数重载"><a href="#3-3函数重载" class="headerlink" title="3.3函数重载"></a>3.3函数重载</h3><h4 id="3-3-1函数重载概述"><a href="#3-3-1函数重载概述" class="headerlink" title="3.3.1函数重载概述"></a>3.3.1函数重载概述</h4><p><strong>作用：</strong> 函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<p><strong>1.在同一个作用域下</strong></p>
<p><strong>2.函数名称相同</strong></p>
<p><strong>3.函数参数类型不同或者个数不同或者顺序不同</strong></p>
<p><strong>注意:</strong> 函数返回值不可以作为函数重载的条件</p>
<p><strong>代码实验：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//函数重载</span><br><span class="line">//**1.在同一个作用域下**</span><br><span class="line">// **2.函数名称相同**</span><br><span class="line">// **3.函数参数类型不同或者个数不同或者顺序不同**</span><br><span class="line">int func(int a)</span><br><span class="line">&#123;</span><br><span class="line">	int b = a;</span><br><span class="line">	cout &lt;&lt; &quot;函数复用！&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	return a,b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int func(int b ,int a)</span><br><span class="line">&#123;</span><br><span class="line">	a = b;</span><br><span class="line">	cout &lt;&lt; &quot;函数复用！！&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	return a,b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a=20 ,b = 10;</span><br><span class="line">	func(a);</span><br><span class="line">	func(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2函数重载注意事项"><a href="#3-3-2函数重载注意事项" class="headerlink" title="3.3.2函数重载注意事项"></a>3.3.2函数重载注意事项</h3><p>· 引用作为重载条件</p>
<p>· 函数重载碰到函数默认参数 </p>
<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4.类和对象"></a>4.类和对象</h2><p>C++面向对象的三大特性：封装、继承、多态</p>
<p>C++认为万事万物都是对象，对象有其属性和行为</p>
<h3 id="4-1封装"><a href="#4-1封装" class="headerlink" title="4.1封装"></a>4.1封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1 封装的意义"></a>4.1.1 封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<p>将属性和行为作为一个整体，表现生活中的事物</p>
<p>将属性和行为加以权限控制</p>
<p>封装意义一：</p>
<p>在设计类的时候，属性和行为写在一起，表现生活中的事物</p>
<p>语法：class 类名{访问权限：属性&#x2F;行为}；</p>
<p>示例：设计一个圆类，，求圆的周长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设计一个圆类，求圆的周长</span><br><span class="line">//圆的周长公式：2*pi*r</span><br><span class="line">const double pi = 3.14;</span><br><span class="line">class Circle </span><br><span class="line">&#123;</span><br><span class="line">	//访问权限</span><br><span class="line">	//公共权限</span><br><span class="line">	public:</span><br><span class="line">	//属性</span><br><span class="line">	//半径</span><br><span class="line">	int r;</span><br><span class="line">	//行为</span><br><span class="line">	//获取圆的周长</span><br><span class="line">	double Caculate(int &amp;r)</span><br><span class="line">	&#123;</span><br><span class="line">		double ZC = 2*pi*r;</span><br><span class="line">		return ZC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	Circle cl;</span><br><span class="line">	cl.r = 10;</span><br><span class="line">	double ZC = cl.Caculate(cl.r);</span><br><span class="line">	cout &lt;&lt; ZC &lt;&lt; endl;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码来看，感觉类和结构体有点相似，都包含了属性，不同的点是，类有访问权限和行为。</p>
<p>案例2：创建一个学生类，属性有姓名和学号，给学生的姓名和学号赋值，可以显示学生的姓名和学号；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设计一个学生类，属性有姓名和学号</span><br><span class="line">//可以给学生的姓名和学号赋值，可以显示学生的姓名和学号</span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">	//访问权限</span><br><span class="line">	public:</span><br><span class="line">	//属性有姓名和学号</span><br><span class="line">	string s_Name;</span><br><span class="line">	long s_Numble;</span><br><span class="line">	//行为是显示学生的姓名和学号</span><br><span class="line">	void displayStudent(string &amp;s_Name,long &amp;s_Numble)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;学生的姓名是 &quot; &lt;&lt; s_Name &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;学生的学号是 &quot; &lt;&lt; s_Numble &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	Student stu;</span><br><span class="line">	stu.s_Name = &quot;Michael&quot;;</span><br><span class="line">	stu.s_Numble = 1805130334;</span><br><span class="line">	stu.displayStudent(stu.s_Name,stu.s_Numble);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/uTools_1649077374818.png"></p>
<p>封装意义二：</p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<p>1.public 公共权限  类内可以访问 类外可以访问</p>
<p>2.protected 保护权限 类内可以访问 类外不可以访问</p>
<p>3.private 私有权限 类内可以访问 类外不可以访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//公共权限 public 类内可以访问 类外可以访问</span><br><span class="line">//保护权限 protected 类内可以访问 类外不可以访问 子类可以访问父类</span><br><span class="line">//私有权限 private 类内可以访问 类外不可以访问</span><br><span class="line">//案例：创建一个人的类 姓名为公共权限 车为保护权限 银行卡密码为私有权限</span><br><span class="line">class person&#123;</span><br><span class="line">	public:</span><br><span class="line">	string p_Name;</span><br><span class="line">	protected:</span><br><span class="line">	string p_Car;</span><br><span class="line">	private:</span><br><span class="line">	int p_Passwad;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	person zs;</span><br><span class="line">	zs.p_Name = &quot;WayJay&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在实验过程中，可以发现除了姓名可以访问，其他都不能访问，也就是类内可以访问私有和保护权限下的属性，类外不可以访问私有和保护权限。</p>
<h4 id="4-1-2-struct-和class-的区别"><a href="#4-1-2-struct-和class-的区别" class="headerlink" title="4.1.2 struct 和class 的区别"></a>4.1.2 struct 和class 的区别</h4><p>在C++中struct 和class唯一的区别就在于默认的访问权限不同</p>
<p>区别：</p>
<p>struct默认权限为公共；</p>
<p>class默认权限为私有；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct C1</span><br><span class="line">&#123;</span><br><span class="line">	string C_Name;</span><br><span class="line">&#125;;</span><br><span class="line">class C2</span><br><span class="line">&#123;</span><br><span class="line">	string C_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123; </span><br><span class="line">	C1 str;</span><br><span class="line">	C2 cla;</span><br><span class="line">	str.C_Name = &quot;张三&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们想要访问class内部的属性时，发现是访问不了的。</p>
<h4 id="4-1-3成员属性设置为私有"><a href="#4-1-3成员属性设置为私有" class="headerlink" title="4.1.3成员属性设置为私有"></a>4.1.3成员属性设置为私有</h4><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p>
<p>优点2：对于写权限，可以检测数据的有效性</p>
<p>示例：设置一个人类，属性包括姓名，年龄，情人</p>
<p>设置姓名为可读可写，年龄为只读，情人为只写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//成员属性私有化</span><br><span class="line">//可以控制读写权限</span><br><span class="line">//检测数据的有效性</span><br><span class="line"></span><br><span class="line">//设置一个人类</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	//设置姓名 可读可写</span><br><span class="line">	void setName(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		p_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	string getName()</span><br><span class="line">	&#123;</span><br><span class="line">		return p_Name;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取年龄 只读</span><br><span class="line">	int getAges()</span><br><span class="line">	&#123;</span><br><span class="line">		p_Ages = 15;</span><br><span class="line">		return p_Ages;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置情人 只写</span><br><span class="line">	void setLover(string lover)</span><br><span class="line">	&#123;</span><br><span class="line">		p_Lover =lover;</span><br><span class="line">	&#125;</span><br><span class="line">	//姓名 可读可写</span><br><span class="line">	string p_Name;</span><br><span class="line">	//年龄 只读</span><br><span class="line">	int p_Ages;</span><br><span class="line">	//情人， 只写 笑死，为什么会有情人这个属性</span><br><span class="line">	string p_Lover;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	person a;</span><br><span class="line">	string name = &quot;WayJay&quot;;</span><br><span class="line">	a.setName(name);</span><br><span class="line">	cout &lt;&lt; a.getName() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a.getAges() &lt;&lt; endl;</span><br><span class="line">	string lover = &quot;小花&quot;;</span><br><span class="line">	a.setLover(lover);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例1:设计立方体</strong></p>
<p>设计立方体</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//先设置一个立方体类</span><br><span class="line">class Cube</span><br><span class="line">&#123;</span><br><span class="line">	private:</span><br><span class="line">	float c_L;</span><br><span class="line">	float c_W;</span><br><span class="line">	float c_H;</span><br><span class="line">	public:</span><br><span class="line">	//设置长</span><br><span class="line">	void setL(float L)</span><br><span class="line">	&#123;</span><br><span class="line">		c_L = L;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取长</span><br><span class="line">	float getL()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_L;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置宽</span><br><span class="line">	void setW(float W)</span><br><span class="line">	&#123;</span><br><span class="line">		c_W = W;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取宽</span><br><span class="line">	float getW()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_W;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置高</span><br><span class="line">	void setH(float H)</span><br><span class="line">	&#123;</span><br><span class="line">		c_H = H;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取高</span><br><span class="line">	float getH()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_H;</span><br><span class="line">	&#125;</span><br><span class="line">	//计算其体积</span><br><span class="line">	double volume()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_L*c_W*c_H;</span><br><span class="line">	&#125;</span><br><span class="line">	//计算其面积</span><br><span class="line">	double area()</span><br><span class="line">	&#123;</span><br><span class="line">		double area = c_L*c_W*2+c_L*c_H*2+c_W*c_H*2;</span><br><span class="line">		return area;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数判断两个立方体是否相等,老师的想法也是一样，用布尔类型来判断</span><br><span class="line">bool judgeCube(Cube &amp;c1,Cube &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">	if(c1.getL() == c2.getL() &amp;&amp; c1.getW() == c2.getW() &amp;&amp; c1.getH() == c2.getH())</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	float L1 =10.5;</span><br><span class="line">	float W1 =5.5;</span><br><span class="line">	float H1 =8.5;</span><br><span class="line">	float L2 =10.5;</span><br><span class="line">	float W2 =6.5;</span><br><span class="line">	float H2 =8.5;</span><br><span class="line">	Cube lft1;</span><br><span class="line">	Cube lft2;</span><br><span class="line">	lft1.setL(L1);</span><br><span class="line">	lft1.setW(W1);</span><br><span class="line">	lft1.setH(H1);</span><br><span class="line">	lft2.setL(L2);</span><br><span class="line">	lft2.setW(W2);</span><br><span class="line">	lft2.setH(H2);</span><br><span class="line">	cout &lt;&lt; &quot;立方体1的体积是&quot; &lt;&lt; lft1.volume() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;立方体1的面积是&quot; &lt;&lt; lft1.area() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;立方体2的体积是&quot; &lt;&lt; lft2.volume() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;立方体2的面积是&quot; &lt;&lt; lft2.area() &lt;&lt; endl;</span><br><span class="line">	bool ret = judgeCube(lft1,lft2);</span><br><span class="line">	if(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;这两个立方体是同一个&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	cout &lt;&lt; &quot;这两个立方体不是同一个&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例：</strong> 设置一个圆类，设置一个点类</p>
<p>判断他们之间的位置关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//练习案例2</span><br><span class="line">//设计一个圆类（circle），设计一个点类（point），计算点和圆的关系</span><br><span class="line">//那么点和圆有什么关系呢，点在圆上？点在圆内，点在圆外？</span><br><span class="line">//怎么判断呢，利用坐标关系</span><br><span class="line">//设置一个点类，属性有x和y坐标</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">	private:</span><br><span class="line">	int p_X;</span><br><span class="line">	int p_Y;</span><br><span class="line">	public:</span><br><span class="line">	//设置x坐标</span><br><span class="line">	void setX(int x)</span><br><span class="line">	&#123;</span><br><span class="line">		p_X = x;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取x坐标</span><br><span class="line">	int getX()</span><br><span class="line">	&#123;</span><br><span class="line">		return p_X;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置y坐标</span><br><span class="line">	void setY(int y)</span><br><span class="line">	&#123;</span><br><span class="line">		p_Y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取Y坐标</span><br><span class="line">	int getY()</span><br><span class="line">	&#123;</span><br><span class="line">		return p_Y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//设置一个圆类。属性有圆心，半径</span><br><span class="line">//行为有设置获取半径，设置获取圆心</span><br><span class="line">class Circle</span><br><span class="line">&#123;</span><br><span class="line">	private:</span><br><span class="line">	Point c_Center;</span><br><span class="line">	int c_R;</span><br><span class="line">	public:</span><br><span class="line">	void setR(int R)</span><br><span class="line">	&#123;</span><br><span class="line">		c_R = R;</span><br><span class="line">	&#125;</span><br><span class="line">	int getR()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_R;</span><br><span class="line">	&#125;</span><br><span class="line">	//设置圆心坐标</span><br><span class="line">	void setCenter(Point center)</span><br><span class="line">	&#123;</span><br><span class="line">		c_Center = center;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取圆心坐标</span><br><span class="line">	Point getCenter()</span><br><span class="line">	&#123;</span><br><span class="line">		return c_Center;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数判断，圆和点之间关系</span><br><span class="line">void isCenter(Circle &amp;c,Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	int distance =</span><br><span class="line">	(c.getCenter().getX()-p.getX())*(c.getCenter().getX()-p.getX())</span><br><span class="line">	+(c.getCenter().getY() - p.getY())*(c.getCenter().getY() - p.getY());</span><br><span class="line">	int R2 = c.getR()*c.getR();</span><br><span class="line">	if(distance == R2)</span><br><span class="line">	cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl;</span><br><span class="line">	else if(distance &gt; R2)</span><br><span class="line">	cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">	cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	//圆、点实例化</span><br><span class="line">	Circle c;</span><br><span class="line">	Point p;</span><br><span class="line">	Point center;</span><br><span class="line">	int centerX =0;</span><br><span class="line">	int centerY=0;</span><br><span class="line">	cout &lt;&lt; &quot;请输入圆心的X坐标 &quot;;</span><br><span class="line">	cin &gt;&gt; centerX;</span><br><span class="line">	cout &lt;&lt; &quot;请输入圆心的Y坐标 &quot;;</span><br><span class="line">	cin &gt;&gt; centerY;</span><br><span class="line">	center.setX(centerX);</span><br><span class="line">	center.setY(centerY);</span><br><span class="line">	//设置圆心坐标、半径</span><br><span class="line">	int r;</span><br><span class="line">	cout &lt;&lt; &quot;请输入圆心的半径 &quot;;</span><br><span class="line">	cin &gt;&gt; r;</span><br><span class="line">	c.setR(r);</span><br><span class="line">	//设置圆心坐标</span><br><span class="line">	c.setCenter(center);</span><br><span class="line">	//设置点的坐标</span><br><span class="line">	int p_X ;</span><br><span class="line">	int p_Y ;</span><br><span class="line">	cout &lt;&lt; &quot;请输入点的X坐标 &quot;;</span><br><span class="line">	cin &gt;&gt; p_X;</span><br><span class="line">	cout &lt;&lt; &quot;请输入点的Y坐标 &quot;;</span><br><span class="line">	cin &gt;&gt; p_Y;</span><br><span class="line">	p.setX(p_X);</span><br><span class="line">	p.setY(p_Y);</span><br><span class="line">	isCenter(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个案例的难点就是这个圆的属性圆心包含了点的属性坐标，这样子就需要创建一个新的定义类型，有点类似于嵌套的结构体。</p>
<h3 id="4-2对象的初始化和清理"><a href="#4-2对象的初始化和清理" class="headerlink" title="4.2对象的初始化和清理"></a>4.2对象的初始化和清理</h3><p>·生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时也会删除一些自己信息数据保证安全</p>
<p>·c++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</p>
<h4 id="4-2-1构造函数和析构函数"><a href="#4-2-1构造函数和析构函数" class="headerlink" title="4.2.1构造函数和析构函数"></a>4.2.1构造函数和析构函数</h4><p>对象的初始化和清理时两个非常重要的安全问题</p>
<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。</p>
<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提析造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。</p>
<p>·构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数有编译器自动调用，无须手动调用。</p>
<p>·析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p>
<p>构造函数语法：类名{}</p>
<p>1.构造函数，没有返回值也不写void</p>
<p>2.函数名称与类名相同</p>
<p>3.构造函数可以有参数，因此可以发生重载</p>
<p>4.程序在调用对象时候会自动调用构造。无须手动调用，而且只会调用一次。</p>
<p>析构函数语法：~类名(){}</p>
<p>1.析构函数，没有返回值也不写void</p>
<p>2.函数名称与类名相同，在名称前加上符号</p>
<p>3.析构函数不可以有参数，因此不可以发生重载</p>
<p>4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//构造函数和析构函数</span><br><span class="line">//对象的初始化和清理</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//构造函数 进行初始化操作</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;peson构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">//析构函数 进行清理的操作</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;person析构函数的调用&quot; &lt;&lt; endl; // 析构函数只有在释放后再清理</span><br><span class="line">		//相比在主函数中，需要在程序结束后才会调用</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test21()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123; </span><br><span class="line">	test21();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2构造函数的分类及调用"><a href="#4-2-2构造函数的分类及调用" class="headerlink" title="4.2.2构造函数的分类及调用"></a>4.2.2构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>按参数分为：有参构造和无参构造</p>
<p>按类型分为：普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>括号法：</p>
<p>注意事项1：在调用默认构造函数时，不要加()</p>
<p>如果加了(),编译器会认为这是一个函数的声明</p>
<p>类似于void func();这是一个函数的声明</p>
<p>注意事项2：不要利用拷贝构造函数 初始化匿名对象 编译器会认为 Person(p3) &#x3D;&#x3D; Person p3 ，就是认为这是对象的实例化，就是创建一个对象。</p>
<p>显示法：</p>
<pre><code>//显示法调用无参构造函数
 Person p1;
//用显示法调用有参构造函数
 Person p2 = Person(10);
//用显示法调用拷贝函数
 Person p3 = Person(p2);
</code></pre>
<p>隐式转换法：</p>
<pre><code>Person p4 = 10; //隐式转换法，调用有参构造函数
Person p5 = p4;//隐式转换法 调用拷贝构造函数
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//构造函数的分类及调用</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//无参构造函数 也叫默认构造函数</span><br><span class="line">	Person ()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">	Person(const Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		//将传入的人身上的所有属性，拷贝到我身上</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line">//怎么调用呢</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//1.括号法</span><br><span class="line">	// Person p1; //默认构造函数的调用</span><br><span class="line">	// Person p2(10); //调用有参构造函数</span><br><span class="line">	// Person p3(p2);</span><br><span class="line">	// //注意事项</span><br><span class="line">	// //在调用默认构造函数的时候，不要加（）</span><br><span class="line">	// cout &lt;&lt; &quot;p2的年龄 &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">	// cout &lt;&lt; &quot;p3的年龄 &quot;  &lt;&lt; p3.age &lt;&lt;endl;</span><br><span class="line">	//2.显示法</span><br><span class="line">	//用显示法调用无参或者是默认调用函数</span><br><span class="line">	// Person p1;</span><br><span class="line">	// //用显示法调用有参构造函数</span><br><span class="line">	// Person p2 = Person(10);</span><br><span class="line">	// //用显示法调用拷贝函数</span><br><span class="line">	// Person p3 = Person(p2);</span><br><span class="line">	// Person(10); //匿名对象，当前行执行结束后，</span><br><span class="line">	//             //系统会立即回收掉匿名对象</span><br><span class="line">	//注意事项，不要利用拷贝构造函数 初始化匿名对象 编译器会认为 Person(p3) == Person p3;</span><br><span class="line">	//3.隐式转换法</span><br><span class="line">	Person p4 = 10; //隐式转换法，调用有参构造函数</span><br><span class="line">	Person p5 = p4;//隐式转换法 调用拷贝构造函数</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3拷贝构造函数调用时机"><a href="#4-2-3拷贝构造函数调用时机" class="headerlink" title="4.2.3拷贝构造函数调用时机"></a>4.2.3拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况：</p>
<p>·使用一个已经创建完毕的对象来初始化一个新对象</p>
<p>·值传递的方式给函数参数传值</p>
<p>·以值方式返回局部对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//拷贝构造函数调用时机</span><br><span class="line">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">// 值传递的方式给函数参数传值</span><br><span class="line">// 以值方式返回局部对象</span><br><span class="line">//先创建一个类</span><br><span class="line">//无参构造函数 有参构造函数 拷贝构造函数</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	Person(int a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(const Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	Person p2(10);</span><br><span class="line">	Person p3(p2);</span><br><span class="line">	cout &lt;&lt; p3.age &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">// 值传递的方式给函数参数传值</span><br><span class="line">void doWork(Person p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;//默认构造函数调用</span><br><span class="line">	doWork(p); //Person p = p;相当于上次学的隐式转换法</span><br><span class="line">&#125;</span><br><span class="line">//值方式返回局部对象</span><br><span class="line">Person doWork2()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	return p1;</span><br><span class="line">&#125;</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">	Person p = doWork2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// test01();</span><br><span class="line">	// test02();</span><br><span class="line">	test03(); //输出无参构造函数，拷贝构造函数，析构函数，析构函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>听完这节课有一点点懵逼，大概就是拷贝构造函数的两种调用方法，一个是括号法，用于用一个已经创建完毕的对象来初始化一个新对象，一个是隐式转换法，用于值传递的方式给函数参数传值，以值方式返回局部对象，这两种的调用方法都类似于隐式转换法的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p4;</span><br><span class="line">Person p = p4;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4构造函数调用规则"><a href="#4-2-4构造函数调用规则" class="headerlink" title="4.2.4构造函数调用规则"></a>4.2.4构造函数调用规则</h4><p>默认情况下，C++编译器至少给一个类添加至少三个函数</p>
<p>**1.**默认构造函数（无参，函数体为空）</p>
<p>**2.**默认析构函数（无参，函数体为空）</p>
<p>**3.**默认拷贝函数，对属性进行拷贝</p>
<p>析构函数调用规则如下;</p>
<p>·如果用户定义有参构造函数，C++不在提供默认无参构造函数，但是会提供默认拷贝函数</p>
<p>·如果用户定义拷贝构造函数，C++不会再提供其他构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//构造函数调用规则</span><br><span class="line">//默认构造函数（无参 函数体为空）</span><br><span class="line">//默认析构函数（无参 函数体为空）</span><br><span class="line">//默认拷贝构造函数，对属性进行值拷贝</span><br><span class="line">//第一步 创建一个结构体</span><br><span class="line">//如果我们写了有参构造函数，编译器就不再提供默认构造，</span><br><span class="line">//依然提供拷贝，大概就是如果你写了有参构造函数，那么默认的无参构造函数就没有了</span><br><span class="line">//这时你去调用无参构造函数，编译器就会报错，但是编译器默认的拷贝构造函数依然存在，</span><br><span class="line">//编译器不会报错</span><br><span class="line">//当我们写了拷贝构造函数，编译器就不会再提供默认构造函数和有参构造函数了</span><br><span class="line">//当自己写了高级构造函数后，那么低级的构造函数，编译器就不会再提供</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person ()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;默认构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数调用</span><br><span class="line">	Person (int age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = age;</span><br><span class="line">		cout &lt;&lt; &quot;有参函数调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造函数，对属性进行值传递</span><br><span class="line">	// Person(const Person &amp; p)</span><br><span class="line">	// &#123;</span><br><span class="line">	// 	m_age = p.m_age;</span><br><span class="line">	// &#125;</span><br><span class="line">	//构造函数</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.m_age = 18;</span><br><span class="line">	Person p2(p); // 将拷贝构造函数注释掉，并不会报错</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为&quot; &lt;&lt; p2.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p(28);</span><br><span class="line">	Person p1(p);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：编译器会自动提供三种函数：默认构造函数、析构函数、拷贝函数</p>
<p>如果我们自己定义了有参构造哈数，那么编译器不会再提供默认构造函数</p>
<p>如果我们自己定义了拷贝构造函数，那么编译器不会再提供默认构造函数和有参构造函数</p>
<h4 id="4-2-5-深拷贝和浅拷贝"><a href="#4-2-5-深拷贝和浅拷贝" class="headerlink" title="4.2.5 深拷贝和浅拷贝"></a>4.2.5 深拷贝和浅拷贝</h4><p>深浅拷贝是面试经典问题，也是一个常见的坑</p>
<p>浅拷贝：：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//深拷贝和浅拷贝</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;默认构造函数&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int age,int height)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = age;</span><br><span class="line">		m_Height = new int (height);</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(const Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		// m_Height = p.m_Height;//编译器默认实现的代码</span><br><span class="line">		m_Height =  new int (*p.m_Height); //为p.Height重新new一个堆区，这样就不会重复释放同一个堆区了</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		//这里会出现一个问题，就是堆区的数据会被二次释放，这就是浅拷贝的一个问题所在</span><br><span class="line">		//free(): double free detected in tcache 2 Aborted</span><br><span class="line">		//怎么解决呢，利用深拷贝来解决</span><br><span class="line">		//自己实现拷贝构造函数，解决浅拷贝带来的问题</span><br><span class="line">		//析构代码，将堆区开辟数据做释放操作</span><br><span class="line">		if(m_Height != NULL)</span><br><span class="line">		delete m_Height;</span><br><span class="line">		m_Height = NULL; //</span><br><span class="line">		cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_age;</span><br><span class="line">	int *m_Height;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p(18,160);</span><br><span class="line">	Person p2(p);</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄&quot; &lt;&lt; p2.m_age&lt;&lt; endl ;</span><br><span class="line">	cout &lt;&lt; &quot;p2的身高&quot; &lt;&lt; *p2.m_Height&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：利用深拷贝解决浅拷贝的值传递在堆区重复释放的问题</p>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong> C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong> 构造函数():属性1（值1），属性2（值2）…（）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//传统初始化操作</span><br><span class="line">	// Person(int A,int B,int C)</span><br><span class="line">	// &#123;</span><br><span class="line">	// 	m_A = A;</span><br><span class="line">	// 	m_B = B;</span><br><span class="line">	// 	m_C = C;</span><br><span class="line">	// &#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">	int m_C;</span><br><span class="line">//初始化列表初始化属性</span><br><span class="line">	Person():m_A(10),m_B(20),m_C(30)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">//另一种语法:</span><br><span class="line">   Person(int A,int B,int C):m_A(A),m_B(B),m_C(C)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p(10,20,30);</span><br><span class="line">	cout &lt;&lt; p.m_A&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_B&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_C&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p2;</span><br><span class="line">	cout &lt;&lt; p2.m_A&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.m_B&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.m_C&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	// test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：用最后一种语法，可以在初始化时赋不同的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person(int A,int B,int C):m_A(A),m_B(B),m_C(C)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类种的成员可以是另一个类的对象，称该成员为对象成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//类对象作为类成员</span><br><span class="line"></span><br><span class="line">//手机类</span><br><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//品牌</span><br><span class="line">	//赋值操作</span><br><span class="line">    Phone(string pname)</span><br><span class="line">	&#123;</span><br><span class="line">		p_Brand = pname;</span><br><span class="line">		cout &lt;&lt;&quot;phone的函数调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Phone()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;phone的析构函数调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string p_Brand;</span><br><span class="line">&#125;;</span><br><span class="line">//人类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//姓名</span><br><span class="line">	//person m_phone - pname;//隐式转换法</span><br><span class="line">	Person(string name,string pname):m_Name(name),m_Phone(pname)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;person的函数调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;person的析构函数调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	//手机</span><br><span class="line">	Phone m_Phone;</span><br><span class="line">	//使用上节课学到的初始化列表来初始化</span><br><span class="line">&#125;;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p2(&quot;李四&quot;,&quot;三星&quot;);</span><br><span class="line">	cout &lt;&lt;p2.m_Name&lt;&lt; &quot;手机的品牌是&quot; &lt;&lt; p2.m_Phone.p_Brand&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// string brand = &quot;华为&quot;;</span><br><span class="line">	// string name = &quot;张三&quot;;</span><br><span class="line">	// Person p;</span><br><span class="line">	// p.m_Name = name;</span><br><span class="line">	// p.m_Phone.p_Brand = brand;</span><br><span class="line">	test02();</span><br><span class="line">	Person p(&quot;张三&quot;,&quot;华为&quot;);</span><br><span class="line">	cout &lt;&lt;p.m_Name&lt;&lt; &quot;手机的品牌是&quot; &lt;&lt; p.m_Phone.p_Brand&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarKang1/picgopicture/img/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%88%90%E5%91%98.png"></p>
<p>结论：可以看出在函数调用过程中，当类中成员是其他类时，我们称该成员为对象成员，构造的顺序时：先调用对象成员的构造，再调用本类构造</p>
<p>析构的顺序是：先调用本类析构，再调用对象成员析构</p>
<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是再成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<p>·所有对象共享同一份数据</p>
<p>·在编译阶段分配内存</p>
<p>·类内声明，类外初始化</p>
<p>静态成员函数</p>
<p>·所有对象共享一个函数</p>
<p>·静态成员函数只能访问静态成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//静态成员函数</span><br><span class="line">//所有对象共享同一个函数</span><br><span class="line">//静态成员函数只能访问静态成员变量</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//静态成员函数</span><br><span class="line">	static void func()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = 100;//静态成员变量是共享的</span><br><span class="line">		// m_B = 100; //非静态成员变量，静态成员函数调用不了</span><br><span class="line">		// 无法区分是哪个对象的m_B</span><br><span class="line">		cout &lt;&lt; &quot;static void func调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//静态成员变量</span><br><span class="line">	static int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	// 两种调用方式</span><br><span class="line">	//通过对象访问</span><br><span class="line">	p.func();</span><br><span class="line">	//通过类名访问</span><br><span class="line">	Person::func();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：静态成员函数的调用有两种方式：1.过类名访问</p>
<p>2.通过对象访问</p>
<p>静态成员函数只能调用静态成员变量</p>
<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数是分开存储的</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//成员变量和成员函数 分开存储的</span><br><span class="line">//先创建一个类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class People</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A; //非静态成员变量，属于类的对象上</span><br><span class="line">	static int m_B;//静态成员变量，不属于类的对象上</span><br><span class="line">	void func()//非静态成员函数，和非静态成员变量是分开存储的</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	//空对象占用内存空间为：1</span><br><span class="line">	//C++编译器会给每个空对象也分配一个字节空间</span><br><span class="line">	//是为了区分空对象占内存的位置</span><br><span class="line">	//每个空对象都应该有自己的一个内存位置</span><br><span class="line">	cout &lt;&lt; sizeof(p) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	People p;</span><br><span class="line">	cout &lt;&lt; sizeof(p) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：只有非静态成员变量属于类的对象上，非静态成员变量和非静态成员函数是分开存储的</p>
<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1，在c++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码？</p>
<p>那么这一块代码是如何区分哪个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用成员函数所属的对象</p>
<p>this指针式隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p><strong>this指针的用途</strong> </p>
<p>·当形参和成员变量同名时，可以用this指针区分</p>
<p>·在类的非静态成员函数中返回对象本身，可使用return *this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//this指针用途</span><br><span class="line">//1.解决名称冲突</span><br><span class="line">//2.返回对象本身用*this</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(int ages)</span><br><span class="line">	&#123;</span><br><span class="line">		//this指针指向的时被调用的成员函数p所属的对象</span><br><span class="line">		//解决了重名冲突</span><br><span class="line">		this-&gt;ages= ages;</span><br><span class="line">	&#125;</span><br><span class="line">	Person &amp;PersonAddAge(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;ages += p.ages;</span><br><span class="line">		return *this;//返回对象本身，例如我们现在调用的p2，那么返回就是p2</span><br><span class="line">	&#125;</span><br><span class="line">	int ages;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(18);</span><br><span class="line">	cout &lt;&lt; p1.ages &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p2(18);</span><br><span class="line">	//链式编程思想</span><br><span class="line">	//返回person类型本身，再次调用person类内的行为或者属性</span><br><span class="line">	p2.PersonAddAge(p2).PersonAddAge(p2);</span><br><span class="line">	cout &lt;&lt; p2.ages &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>代码实验</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	void showClassName()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPersonAge()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Person&#x27;s ages are&quot; &lt;&lt; m_Age &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person *p = NULL;</span><br><span class="line">	p-&gt;showClassName();</span><br><span class="line">	p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用函数showPersonAge时，报错</p>
<p>Segmentation fault （段错误）</p>
<p>报错指针是因为传入的指针为NULL，空指针不能指向m_Age这个对象</p>
<p>怎么解决呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在showPersonAgeh函数中加入一个判断语句</span><br><span class="line">if(this == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;//空指针直接return</span><br><span class="line">&#125;</span><br><span class="line">这样子就不会报错了</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数</strong>： </p>
<p>·成员函数后加const后，我们称中国函数为常函数 </p>
<p>·常函数内不可以修改成员属性</p>
<p>·成员属性声明加关键字mutable后，在常函数中依然可以修改</p>
<p>​	<strong>常对象：</strong></p>
<p>·声明对象前加const称该对象为常对象</p>
<p>·常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//常函数</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//this指针的本质 是指针常量 指针的指向是不可以修改的</span><br><span class="line">	//类似于int * const p或者是Person const *this 修饰的是p和this的地址</span><br><span class="line">	//当函数后加上const后，指针就类似于const Person * const p 指针的值和地址都不能被修改</span><br><span class="line">	void showPerson() const</span><br><span class="line">	&#123;</span><br><span class="line">		m_B = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B;//当加上mutable后，这就是一个特殊变量，常函数可以修改这个值</span><br><span class="line">&#125;;</span><br><span class="line">//常对象</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	const Person p;//在创建的对象前加上const就是常对象,这个对象的值也不能修改</span><br><span class="line">	//若需要修改，需要在变量前加上mutable</span><br><span class="line">	p.showPerson();//常对象只能调用常函数，不能调用其他函数</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论：常函数和常对象只能调用加上mutable的特殊变量，而且常对象只能调用常函数，不能调用其他函数。</p>
<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Pubc),有你的卧室(Private)<br>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去<br>但是呢，你也可以允许你的好闺蜜好基友进去。<br>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p><strong>友元的目的</strong>就是让一个函数或者类访问另一个类中私有成员<br>友元的关键字为friend</p>
<p><strong>友元的三种实现</strong><br>·全局函数做友元<br>·类做友元<br>·成员函数做友元</p>
<p><strong>全局函数做友元</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//友元</span><br><span class="line">//全局函数做友元</span><br><span class="line">//类做友元</span><br><span class="line">//成员函数做友元</span><br><span class="line">//房子类</span><br><span class="line">class Building </span><br><span class="line">&#123;</span><br><span class="line">	friend void goodGay(Building &amp;Building);//全局函数声明，让goodgay这个函数可以访问building类中的私有成员</span><br><span class="line">public:</span><br><span class="line">	Building()</span><br><span class="line">	&#123;</span><br><span class="line">		m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">		m_SittringRoom = &quot;客厅&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_SittringRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom;//卧室，私有属性</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building &amp;Building)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;好基友全局函数，正在访问： &quot; &lt;&lt; Building.m_BedRoom&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;好基友全局函数，正在访问： &quot; &lt;&lt; Building.m_SittringRoom&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	goodGay(building);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>类做友元</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//类做友元</span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">	friend class GoodGay;</span><br><span class="line">public:</span><br><span class="line">	Building();</span><br><span class="line">	//属性有客厅和卧室 </span><br><span class="line">	//卧室为私有的</span><br><span class="line">	string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">class GoodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	GoodGay();</span><br><span class="line">	void visit();//参观函数， 访问Building中的属性</span><br><span class="line">	Building * building;</span><br><span class="line">&#125;;</span><br><span class="line">//类外访问类内函数</span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">	m_SittingRoom  = &quot;客厅&quot;;</span><br><span class="line">	m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">&#125;	</span><br><span class="line">GoodGay::GoodGay()</span><br><span class="line">&#123;</span><br><span class="line">	//创建一个建筑物的对象</span><br><span class="line">	building = new Building;//new一个Building</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&quot;好基友正在访问&quot; &lt;&lt;building-&gt;m_BedRoom &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test001()</span><br><span class="line">&#123;</span><br><span class="line">	GoodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test001();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员函数做友元</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//成员函数做友元</span><br><span class="line">class Building;</span><br><span class="line">class GoodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	GoodGay();</span><br><span class="line">	void visit();//让visit函数可以访问Building中私有成员</span><br><span class="line">	void visit2();//让visit2不能访问Building中私有成员</span><br><span class="line">	Building * building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">	friend void GoodGay::visit();</span><br><span class="line">public:</span><br><span class="line">	//属性：客厅 私有属性：卧室</span><br><span class="line">	Building();</span><br><span class="line">	string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">	m_SittingRoom = &quot;客厅&quot;;</span><br><span class="line">	m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::GoodGay()</span><br><span class="line">&#123;</span><br><span class="line">	building = new Building;</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;你的好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;你的朋友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	GoodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">	gg.visit2();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong> 不论是哪种友元，只需要在你需要访问私有属性或者行为的类里，加上friend对这个函数进行声明即可。</p>
<h3 id="4-5运算符重载"><a href="#4-5运算符重载" class="headerlink" title="4.5运算符重载"></a>4.5运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1加号运算符重载"><a href="#4-5-1加号运算符重载" class="headerlink" title="4.5.1加号运算符重载"></a>4.5.1加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<p>怎么进行两个对象的相加再赋值给第三个对象，用重载+运算符operator+ </p>
<p>代码实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person operator+(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">	return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">Person operator+(Person &amp; p,int a)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p.m_A + a;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = 110;</span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = 20;</span><br><span class="line">	Person p3 = p1 + p2;</span><br><span class="line">	Person p4 = p3 + 100;</span><br><span class="line">	cout &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：运算符重载可以发生在成员函数，也可以发生在全局函数</p>
<p>还能发生函数重载。</p>
<h4 id="4-5-2-左移重载运算符"><a href="#4-5-2-左移重载运算符" class="headerlink" title="4.5.2 左移重载运算符"></a>4.5.2 左移重载运算符</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//左移运算符重载</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person operator&lt;&lt;(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = this-&gt;m_A &lt;&lt; 1;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">Person operator&lt;&lt;(Person &amp;p,int a)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p.m_A &lt;&lt; a;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;cout , Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;m_A=&quot; &lt;&lt; p.m_A &lt;&lt; &quot;m_B= &quot; &lt;&lt; p.m_B;</span><br><span class="line">	return cout; //返回输出流类型，链式编程，可以连续调用</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.m_A = 100;</span><br><span class="line">	p.m_B = 10;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	Person x = p&lt;&lt;1;</span><br><span class="line">	Person y = operator&lt;&lt;(p,3);</span><br><span class="line">	cout &lt;&lt; x.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; y.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3-递增递减运算符"><a href="#4-5-3-递增递减运算符" class="headerlink" title="4.5.3 递增递减运算符"></a>4.5.3 递增递减运算符</h4><p><strong>代码实验：</strong></p>
<p>递增实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递减运算符重载</span><br><span class="line">class MyInteger</span><br><span class="line">&#123;</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;&amp;myint);</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;myint);</span><br><span class="line">private:</span><br><span class="line">	/* data */</span><br><span class="line">	int m_Num;</span><br><span class="line">public:</span><br><span class="line">	MyInteger(/* args */)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = 30;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置++运算符重载</span><br><span class="line">	MyInteger &amp;operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置++运算符重载</span><br><span class="line">	MyInteger operator++(int)</span><br><span class="line">	&#123;</span><br><span class="line">		MyInteger temp = *this;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	~MyInteger()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;&amp;myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test01()//测试前置++ //测试成功</span><br><span class="line">&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line">	cout &lt;&lt; ++(++myint) &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line">	cout &lt;&lt; myint++ &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递减实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递减运算符重载</span><br><span class="line">class MyInteger</span><br><span class="line">&#123;</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;&amp;myint);</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;myint);</span><br><span class="line">private:</span><br><span class="line">	/* data */</span><br><span class="line">	int m_Num;</span><br><span class="line">public:</span><br><span class="line">	MyInteger(/* args */)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = 30;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置--运算符重载</span><br><span class="line">	MyInteger &amp;operator--()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num--;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置--运算符重载</span><br><span class="line">	MyInteger operator--(int)</span><br><span class="line">	&#123;</span><br><span class="line">		MyInteger temp = *this;</span><br><span class="line">		m_Num--;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	~MyInteger()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;cout,MyInteger &amp;&amp;myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test01()//测试前置-- //测试成功</span><br><span class="line">&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line">	cout &lt;&lt; --(--myint) &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line">	cout &lt;&lt; myint-- &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：前置++（–）和后置++（–）的区别是，前置返回的是引用，后置返回的是一个MyInteger类型的值，在引用cout时也有区别，前置的参数是作为左值，后置的参数是作为右值</strong></p>
<h4 id="4-5-4赋值运算符重载"><a href="#4-5-4赋值运算符重载" class="headerlink" title="4.5.4赋值运算符重载"></a>4.5.4赋值运算符重载</h4><p>C++编译器至少给一个类添加4个函数</p>
<p>1.默认构造函数</p>
<p>2.默认析构函数</p>
<p>3.默认拷贝函数</p>
<p>4.赋值运算符operator &#x3D; ，对属性进行值拷贝</p>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//又回到了深浅拷贝的问题</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	/* data */</span><br><span class="line">public:</span><br><span class="line">	int *m_Age;</span><br><span class="line">	//写一个重载赋值运算符</span><br><span class="line">	Person operator=(const Person &amp;p);</span><br><span class="line">	Person(int ages);</span><br><span class="line">	// Person(const Person &amp; p);</span><br><span class="line">	~Person();</span><br><span class="line">&#125;;</span><br><span class="line">Person::Person(int ages)</span><br><span class="line">&#123;</span><br><span class="line">	m_Age = new int(ages);</span><br><span class="line">&#125;</span><br><span class="line">Person::~Person()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">// 	//堆区需要手动释放</span><br><span class="line">// 	if(m_Age != NULL)</span><br><span class="line">// 	&#123;</span><br><span class="line">// 		delete m_Age;</span><br><span class="line">// 		m_Age = NULL;</span><br><span class="line">// 	&#125;</span><br><span class="line">// &#125;</span><br><span class="line">// Person::Person(const Person &amp; p)</span><br><span class="line">// &#123;</span><br><span class="line">// 	m_Age = new int(*p.m_Age);//深拷贝函数</span><br><span class="line">// &#125;</span><br><span class="line">Person Person::operator=(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	//先判断是否有属性在堆区，如果有就先释放干净，然后再深拷贝</span><br><span class="line">	if(m_Age != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_Age;</span><br><span class="line">		m_Age = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	m_Age = new int(*p.m_Age);//深拷贝</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10);</span><br><span class="line">	Person p2(20);</span><br><span class="line">	Person p3(30);</span><br><span class="line">	p2 = p1 = p3;//调用拷贝函数</span><br><span class="line">	cout &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p3.m_Age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-函数调用运算符重载"><a href="#4-5-5-函数调用运算符重载" class="headerlink" title="4.5.5 函数调用运算符重载"></a>4.5.5 函数调用运算符重载</h4><p>·函数调用运算符（）也考验重载</p>
<p>·由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>·仿函数没有固定写法，非常灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//函数调用运算符重载</span><br><span class="line">//打印输出类</span><br><span class="line">class Myprint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//重载运算符调用</span><br><span class="line">	void operator()(string test);</span><br><span class="line">	int operator()(int a, int b);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void Myprint::operator()(string test)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int Myprint::operator()(int a , int b)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = a + b;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Myprint mp;</span><br><span class="line">	mp(&quot;hello world！&quot;);</span><br><span class="line">	cout &lt;&lt; mp(10,20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">WayJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/31/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">http://example.com/2022/03/31/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/id/802/300/300" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/05/%E5%BC%80%E6%BA%90%E8%BD%BB%E9%87%8F%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6lvgl/" title="开源轻量显示框架lvgl"><img class="cover" src="https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">开源轻量显示框架lvgl</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/27/C-%E5%AE%9E%E6%88%98-%E9%80%9A%E8%AE%AF%E5%BD%95/" title="C++实战-通讯录"><img class="cover" src="https://picsum.photos/id/223/300/300" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">C++实战-通讯录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/23/C-%E5%9F%BA%E7%A1%80-%E4%B8%89/" title="C++基础(三)"><img class="cover" src="https://picsum.photos/id/63/300/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">C++基础(三)</div></div></a></div><div><a href="/2022/03/23/C-%E5%9F%BA%E7%A1%80-4/" title="C++基础(四)"><img class="cover" src="https://picsum.photos/id/861/300/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">C++基础(四)</div></div></a></div><div><a href="/2022/03/24/C-%E5%9F%BA%E7%A1%80-%E5%85%AD/" title="C++基础(六)"><img class="cover" src="https://picsum.photos/id/293/300/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">C++基础(六)</div></div></a></div><div><a href="/2022/03/21/C-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/" title="C++基础（二）"><img class="cover" src="https://picsum.photos/id/345/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">C++基础（二）</div></div></a></div><div><a href="/2022/03/24/C-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89/" title="C++基础（五）"><img class="cover" src="https://picsum.photos/id/352/300/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">C++基础（五）</div></div></a></div><div><a href="/2022/03/27/C-%E5%AE%9E%E6%88%98-%E9%80%9A%E8%AE%AF%E5%BD%95/" title="C++实战-通讯录"><img class="cover" src="https://picsum.photos/id/223/300/300" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">C++实战-通讯录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img.wxcha.com/file/201808/31/9b99c1b0d7.jpg?down" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WayJay</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/StarKang1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/xu-weijian" target="_blank" title=""><i class="iconfont icon-gitee"></i></a><a class="social-icon" href="mailto:xwj1154176815@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C++核心编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1内存分区模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1程序运行前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2程序运行后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 new操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 引用的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2引用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">引用做函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 引用做函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.3常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98"><span class="toc-number">1.3.</span> <span class="toc-text">3.函数提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1函数默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2函数占位参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1函数重载概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.3.2函数重载注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">4.类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 封装的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-struct-%E5%92%8Cclass-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 struct 和class 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3成员属性设置为私有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2对象的初始化和清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2构造函数的分类及调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3拷贝构造函数调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.2.4构造函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">4.2.5 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">4.2.6 初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">4.2.7 类对象作为类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-8-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">4.2.8 静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 C++对象模型和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 this指针概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3 空指针访问成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4 const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">4.5.1加号运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%B7%A6%E7%A7%BB%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">4.5.2 左移重载运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">4.5.3 递增递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">4.5.4赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.5.5.</span> <span class="toc-text">4.5.5 函数调用运算符重载</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/Disable-specific-warnings-from-cpplint/" title="Disable specific warnings from cpplint"><img src="https://picsum.photos/id/88/300/300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Disable specific warnings from cpplint"/></a><div class="content"><a class="title" href="/2022/04/16/Disable-specific-warnings-from-cpplint/" title="Disable specific warnings from cpplint">Disable specific warnings from cpplint</a><time datetime="2022-04-16T15:50:09.000Z" title="Created 2022-04-16 23:50:09">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%9B%9B/" title="C++核心编程(四)"><img src="https://picsum.photos/id/76/300/300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++核心编程(四)"/></a><div class="content"><a class="title" href="/2022/04/16/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%9B%9B/" title="C++核心编程(四)">C++核心编程(四)</a><time datetime="2022-04-16T12:57:54.000Z" title="Created 2022-04-16 20:57:54">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/12/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%B8%89/" title="C++核心编程(三)"><img src="https://picsum.photos/id/100/300/300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++核心编程(三)"/></a><div class="content"><a class="title" href="/2022/04/12/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%B8%89/" title="C++核心编程(三)">C++核心编程(三)</a><time datetime="2022-04-12T14:21:31.000Z" title="Created 2022-04-12 22:21:31">2022-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/12/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%BA%8C/" title="C++核心编程(二)"><img src="https://picsum.photos/id/345/300/300" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++核心编程(二)"/></a><div class="content"><a class="title" href="/2022/04/12/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%BA%8C/" title="C++核心编程(二)">C++核心编程(二)</a><time datetime="2022-04-11T16:11:39.000Z" title="Created 2022-04-12 00:11:39">2022-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/%E5%BC%80%E6%BA%90%E8%BD%BB%E9%87%8F%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6lvgl/" title="开源轻量显示框架lvgl"><img src="https://w.wallhaven.cc/full/rd/wallhaven-rdwjj7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开源轻量显示框架lvgl"/></a><div class="content"><a class="title" href="/2022/04/05/%E5%BC%80%E6%BA%90%E8%BD%BB%E9%87%8F%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6lvgl/" title="开源轻量显示框架lvgl">开源轻量显示框架lvgl</a><time datetime="2022-04-05T08:28:10.000Z" title="Created 2022-04-05 16:28:10">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By WayJay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>